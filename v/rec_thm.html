<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>constructive proof of the recursion theorem</title>
    <link rel="stylesheet" href="../style.css"/>
    <!-- twitter emoji icon from favicon.io -->
    <link rel="icon" type="image/png" href="../favicon.png"/>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
      MathJax = {
        tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <main class="paper">
      <h1>constructive proof of the recursion theorem</h1>
      <blockquote><em>
        Let \( S \) be a set, \(\varphi: S \to S\), \(a \in S\).
        Then there exists exactly one \(f: \mathbb{N} \to S\) such that
        <ol>
          <li>\(f(0) = a\),</li>
          <li>\(f(n^+) = \varphi(f(n)), n \in \mathbb{N}\).</li>
        </ol>
      </em></blockquote>
      <p>
        where \(n^+\) denotes \(n\)'s successor per Peano's axioms.
        this theorem is given in the introductory chapter of Nathan Jacobson's <em>Basic Algebra I</em>
        followed by a somewhat lengthy inductive proof "due independently to P. Lorenzen, and to
        D. Hilbert and P. Bernays (jointly)". Jacobson remarks that "One is tempted to say that one can <em>define</em>
        \(f\) inductively by conditions 1 and 2. However, this does not make sense since in talking about
        a function on \(\mathbb{N}\) we must have an a priori definition of \(f(n)\) for every \(n \in \mathbb{N}\)."
      </p>
      <p>
        to programmers this may seem strangely pedantic, since we're used to thinking of "functions" precisely as procedures.
        but i get it. without a ground concept of what a function is (a set of ordered pairs that's total and
        single-valued over its domain), how would we ask if two different procedures define equivalent functions or not?
      </p>
      <p>
        still, the proof given in the book seems kind of excessively tedious and abstract to me. it constructs
        a set satisfying (1) and (2) as an infinite intersection of subsets of \(\mathbb{N} \times S\)
        containing the necessary pairs, then shows inductively that the resulting set is single-valued.
        but instead of an "inductive definition" of the kind that Jacobson finds objectionable, we can
        give a short explicit procedure for generating the desired set, like this:
      </p>
      <p>
        start at \((0, a)\) and make an infinite sequence of pairs like so:
        to get the next element, apply \((n, x) \mapsto (n^+, \varphi(x))\) to the current element.
        the set of elements in the sequence is the desired function \(f\): it is total by Peano's axiom of
        induction, single-valued by the successor map axioms, and
        satisfies properties (1) and (2) by construction. hence \(f\) exists. now let
        \(g: \mathbb{N} \to S, \space g \ne f\) also satisfy (1) and (2). then for some
        \(n \in \mathbb{N}, \space g(n) \ne f(n)\). if \(n = 0\) then \(g\) does not satisfy
        condition (1); otherwise \(g\) does not satisfy condition (2). either case is contradictory.
        therefore \(g = f\) and \(f\) is unique.
      </p>
      <p>
        now we get to write that little square, \(\square\), fun! but this theorem is right at the limit of
        obviousness. if you think about what it would mean, for \(f\) not to exist, or for \(g \ne f\) to
        have the same properties, it's immediately clear that doesn't make sense. a proof of this theorem
        is a way of articulating that. but if the proof complicates a simple proposition to the point
        that it hides more than it shows, what good is it? "to prove" literally means "to show"!
      </p>
    </main>
    <footer><nav><ol>
      <li><a href="./..">ðŸ›–</a></li>
      <li><a href=".">ðŸªž</a></li>
      <li>ðŸ§±</li>
    </ol></nav></footer>
  </body>
</html>

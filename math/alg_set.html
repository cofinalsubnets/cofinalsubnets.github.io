<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>an algebraic set theory</title>
    <link rel="stylesheet" href="../style.css"/>
    <!-- twitter emoji icon from favicon.io -->
    <link rel="icon" type="image/png" href="../favicon.png"/>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
      MathJax = {
        tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <main class="paper">
      <h1>an algebraic set theory</h1>
      <p>
        disclaimer 1: again, like it says on the index page, i'm not a real mathematician.
        so take all of this with a grain of salt and assume there are mistakes.
      </p>
      <p>
        disclaimer 2: there's nothing here that's really new or illuminating.
        it's just a take on sets that i had one day and thought was interesting. this is just
        for fun!
      </p>
      <p>
        start with a collection of things. you can call them "elements" or "points" but they
        aren't exactly the same as elements in traditional set theory. what they are is the
        generators of a monoid. but each one corresponds to some object, which may itself be
        a "set" in the sense 
      </p>
      <p>
        normally monoids are defined on top of sets, but since we don't have sets yet, we just
        say collection, or class if you prefer. by analogy to categories, which are called
        "small" if the underlying collections are proper sets, you can call this a "large"
        monoid if you want. if calling this thing a "monoid" seriously bothers you then just
        wait, we'll get around it in a minute.
      </p>
      <p>
        with respect to the top-level collection, it does no good to ask if any particular
        thing is in it. anyway, we haven't even defined how to do that yet. but by definition,
        as much is in it as possible.
      </p>
      <p>
        out of this collection, one element is distinguished as the empty set. this
        is the identity of the monoid. the other elements correspond to singleton sets, and
        each holds a single element that a particular set may contain. the binary operation
        on this monoid corresponds to set union, and we define it to be commutative and
        idempotent with respect to every element. note that there are no "bare" elements
        in this theory, but the singleton of another singleton, or of the empty set, is
        allowed.
      </p>
      <p>
        so now to recover the familiar set operations. union is just the
        monoid operation, by which the set \( \{ 1, 2, 3 \} \) is constructed as
        \( \{1\} \cup \{2\} \cup \{3\} \). we define intersection by defining a "functor
        into \( \textbf{Set} \)" (i can sense the irony of using this concept when trying
        to define sets, so sorry about that) that sends each generating element \( g \)
        of the monoid (let's call it \( \text{S} \)) to the functor
        (<a href="mono_homo.html">yes, functor</a>; just hang a second) that sends
        generating elements \(h\) to
      </p>
      <p>
      \begin{align}
      h \mapsto h \space \text{if} \space g = h \space \text{else} \space \emptyset
      \end{align}
      </p>
      <p>
        and, since it's a functor, acts "transparently" through composite elements. also
        in mind that the element of \(\text{S}\) representing the singleton set of another set
        is a generating element, even though it is "internally" composite.
      </p>
      <p>
        so each element \(s\) of \(\text{S}\) defines a unique monoid homomorphism that removes
        every element not in \(s\) by sending it to the empty set. we can use the intersection
        functor to test for membership by applying it to a generator, and applying the resulting
        map to the set in question. the result will then be the empty set iff the element is
        not in the set. we can also define the set difference operation as another functor sending
        \(g\) to the "dual" functor sending generating elements \(h\) to
      </p>
      <p>
      \begin{align}
      h \mapsto \emptyset \space \text{if} \space g = h \space \text{else} \space h
      \end{align}
      </p>
      <p>
        speaking of things that are "dual", i would expect that an isomorphic twin formulation,
        where the monoid operation corresponds to intersection and the identity is the total set
        rather than the null set, is also possible. in that case we could accomplish the
        non-intrinsic operation between two sets by crossing over to the other representation
        via complement and combining them there, which would be aesthetically nicer than defining
        intersection as a "one-sided" endofunctor. maybe later!
      </p>
      <p>
        anyway, since we're calling these things functors we might as well go ahead and give this idea
        the full categorical treatment, which is more technically correct anyway for the reason
        mentioned above. the most basic way to do this is to say our monoid is now a single-object
        category that i'll call \(\textbf{Setting}\) because, well, it's the setting. now we can
        talk about functors comfortably and observe that set difference and intersection are
        effectively families of forgetful endofunctors on \(\textbf{Setting}\) indexed one-to-one
        by its morphisms.
      </p>
      <p>
        but single-object categories aren't that interesting. we can get more mileage out
        of this idea by adding some more objects, which are subobjects of the top object.
        in addition to the top object, we have a bottom object, corresponding to to the
        empty set, with no subobjects at all. if we want to, we can view \(\textbf{Setting}\)
        as a lattice of types, which corresponds to a poset category with the expected
        universal objects. but for our purposes \(\textbf{Setting}\) is a discrete category:
        all arrows have the same source and target. for this reason we can refer to the
        homset of one of its objects as \(\textbf{Setting}(\bullet)\) without ambiguity.
      </p>
      <p>
        we need to give \(\textbf{Setting}\) some additional structure. for any object,
        refer to its "superset", which is the composite of all of its generators, and which
        we'll write as \(\bullet^\star\). you could also say that an object's superset is
        characterized by the fact that its image under the intersection "metafunctor" is
        (uniquely) the identity map.
        for any object or morphism, we can also refer to its "singleton", which is
        respectively the object whose generators are the singletons of each of the original
        object's morphisms, or the singleton set of the set represented by the morphism.
      </p>
      <p>
        brief aside concerning Russel's paradox: you may be thinking at this point, "wait
        a minute, taking the superset of the top object's singleton is the same as asking
        for the set of all sets! no bueno ai!" well again, i'm not a real mathematician,
        but to my mind, there's nothing paradoxical about saying "give me the set of all
        possible sets please". the paradox comes when you say "give me all sets satisfying
        some contradictory self-referential predicate". we only call it a "paradox"
        because we naively assume that all formally correct set-builder type
        constructions are legitimate, but then we encounter a "runtime error" as it were
        when we actually try and construct it. imo the contradiction lives in the
        <em>membership criterion</em> for the impossible set you're trying to build.
        it's not intrinsic to the concept of "set of all sets" or whatever. if you apply
        a sound membership criterion, eg. none at all, then you're (probably?) fine.
      </p>
      <p>
        anyway, now we can define a product on \(\textbf{Setting}\) in terms of supersets,
        where the generators of the product object are the singletons of the elements of
        the cartesian product of the supersets of its source objects. the bottom object, of
        course, is the effectively the identity with respect to this operation. since
        \(\textbf{Setting}\) is a discrete category, it doesn't have products in the
        "proper" categorical sense, but we can call this object a product and write it as
        \(\bullet \times \bullet\).
      </p>
      <p>
        now we can make some fun observations:
      </p>
      <ul>
        <li>a set is a morphism in \(\textbf{Setting}\)</li>
        <li>homsets are powersets of supersets: \(\textbf{Setting}(\bullet) = \wp(\bullet^\star)\)</li>
        <li>a relation \(\text{A}\to\text{B}\) is a morphism of \(\text{A} \times \text{B}\)</li>
        <li>(partial) functions of all sorts can be defined analogously</li>
        <li>total functions index functors between singleton subcategories of \(\textbf{Setting}\)</li>
      </ul>
      <p>
        so is this a better setting for general-purpose math stuff than \(\textbf{Set}\)? um, no lol.
        i mean, i even used a functor into \(\textbf{Set}\) in the definition! maybe, by working in
        \(\textbf{Setting}^{\textbf{Setting}}\) and extending the induced functors, you could
        recover the same structure, at the cost of a bunch of fussy indirection. but like i said, i
        don't think there's anything much new here.
      </p>
      <p>
        on the other hand we don't directly use the axiomatic foundations of set theory or
        arithmetic most of the time either. the point isn't that it's directly practical, it's just
        another way to think about what's going on underneath. in this case we get nicely explicit
        procedural definitions of basic set operations, that also use concepts from abstract
        algebra that aren't usually considered as part of "set theory".
      </p>
    </main>
    <footer><nav><ol>
      <li><a href="./..">üõñ</a></li>
      <li><a href=".">üßÆ</a></li>
      <li>‚úñÔ∏è</li>
    </ol></nav></footer>
  </body>
</html>
